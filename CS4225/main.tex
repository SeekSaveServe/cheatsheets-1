\documentclass[10pt, landscape]{article}
\usepackage[scaled=0.92]{helvet}
\usepackage{calc}
\usepackage{multicol}
\usepackage[a4paper,margin=3mm,landscape]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\usepackage{color,graphicx,overpic}
\usepackage{hyperref}
\usepackage{newtxtext} 
\usepackage{enumitem}
\usepackage[table]{xcolor}
\usepackage{mathtools}
\setlist{nosep}
\usepackage{subfig}
\usepackage{listings}

% Define Rust language for listings package
\lstdefinelanguage{Rust}{
  morekeywords={let, mut},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}

% for including images
\graphicspath{ {./images/} }


\pdfinfo{
  /Title (CS4225.pdf)
  /Creator (TeX)
  /Producer (pdfTeX 1.40.0)
  /Author (Pei Cheng Yi)
  /Subject (CS4225)
  /Keywords (CS4225, nus,cheatsheet,pdf)}

% Turn off header and footer
\pagestyle{empty}

\newenvironment{tightcenter}{%
  \setlength\topsep{0pt}
  \setlength\parskip{0pt}
  \begin{center}
}{%
  \end{center}
}

% redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\small\bfseries}}%
\renewcommand{\familydefault}{\sfdefault}
\renewcommand\rmdefault{\sfdefault}
%  makes nested numbering (e.g. 1.1.1, 1.1.2, etc)
\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}
\renewcommand\labelitemii{•}
\renewcommand\labelitemiii{•}
%  convenient absolute value symbol
\newcommand{\abs}[1]{\vert #1 \vert}
%  convenient floor and ceiling
\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\ceil}[1]{\lceil #1 \rceil}
%  convenient modulo
\newcommand{\Mod}[1]{\ \mathrm{mod}\ #1}
%  for logical not operator, iff symbol, convenient "if/then"
\renewcommand{\lnot}{\mathord{\sim}}
\let\then\Rightarrow
\let\Then\Rightarrow
%  vectors
\newcommand{\vv}[1]{\boldsymbol{#1}}
\newcommand{\VV}[1]{\overrightarrow{#1}}
%  column vector
\newcommand{\cvv}[1]{\left(\begin{smallmatrix}#1\end{smallmatrix}\right)}
\newcommand{\code}[1]{\textcolor{myblue}{\texttt{#1}}}
\newcommand\bggreen{\cellcolor{green!10}}

\makeatother
\definecolor{myblue}{cmyk}{1,.72,0,.38}
\everymath\expandafter{\the\everymath \color{myblue}}
% Define BibTeX command
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Don't print section numbers
\setcounter{secnumdepth}{0}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}
%% this changes all items (enumerate and itemize)
\setlength{\leftmargini}{0.5cm}
\setlength{\leftmarginii}{0.4cm}
\setlength{\leftmarginiii}{0.5cm}
\setlist[enumerate,1]{leftmargin=2mm,labelindent=1mm,labelsep=1mm}
\setlist[itemize,1]{leftmargin=2mm,labelindent=1mm,labelsep=1mm}
\setlist[itemize,2]{leftmargin=3mm,labelindent=1mm,labelsep=1mm}
\setlist[itemize,3]{leftmargin=3mm,labelindent=1mm,labelsep=1mm}

%My Environments
\newtheorem{example}[section]{Example}
% -----------------------------------------------------------------------

\begin{document}
\raggedright
\footnotesize
\begin{multicols}{4}


% multicol parameters
% These lengths are set only within the two main columns
\setlength{\columnseprule}{0.25pt}
\setlength{\premulticols}{1pt}
\setlength{\postmulticols}{1pt}
\setlength{\multicolsep}{1pt}
\setlength{\columnsep}{2pt}

\begin{center}
    \fbox{%
        \parbox{0.8\linewidth}{\centering \textcolor{black}{
            {\Large\textbf{CS3231}}
            \\ \normalsize{AY23/24 S1}}
            \\ {\footnotesize \textcolor{myblue}{github.com/SeekSaveServe}}
        }%
    }
\end{center}

% LECTURES

\section{Lectures}

\subsection{L1: Introduction}
\textbf{Four Vs of Data Science}
\begin{itemize}
  \item Volume 
  \item Variety
  \item Velocity 
  \item Veracity - uncertainty of data
\end{itemize}

\textbf{Storage Hierarchy}
\begin{itemize}
  \item Volume: Server $le$ Rack $le$ Cluster 
  \item Speed: Server $ge$ Rack $ge$ Cluster 
\end{itemize}

\textbf{Bandwidth vs Latency}
\begin{itemize}
  \item \textbf{Throughput} Actual rate at which data is transmitted across the network over a period of time
  \item \textbf{Bandwidth} Maximum (capacity) amount of data that can be transmitted per unit time 
  \item \textbf{Latency} Time taken for 1 data packet to go from source to destination (or both ways)
  \item Latency does not matter when transmitting a large amount of data 
  \item Bandwith does not matter when transmitting a small amount of data
\end{itemize}

\textbf{Cost of moving data }
\includegraphics*[width=7cm]{data_cost}
\begin{itemize}
  \item Bandwidth drops and latency increases as we move up the data hierarchy 
  \item Disk reads are also much more expensive 
\end{itemize}

\textbf{Big ideas of data processing}
\begin{itemize}
  \item Horizontal scaling is cheaper than vertical scaling 
  \item Move data processing to the machine with the data since data clusters have limited bandwidth
  \item Process data sequentially and avoid random access to reduce total seek time 
  \item Seamless scalability $\rightarrow$ use more machines to reduce time taken to process data
\end{itemize}

\textbf{Challenges}
\begin{itemize}
  \item Machine failures
  \item Synchronisation 
  \item Programming difficulty
\end{itemize}

\subsection*{L2 Map reduce}
\includegraphics*[width=7cm]{map_reduce}
\begin{itemize}
  \item Map: extract something of interest from each. Emits a key value pair 
  \item Shuffle: Shuffle intermediate results by key value pairs 
  \item Reduce: Aggregate intermediate results
  \item Each of these three processes can occur concurently across different machines
\end{itemize}

\includegraphics*[width=7cm]{map_reduce_impl}
\textbf{Map Reduce Implementation}
\begin{enumerate}
  \item \textbf{Submit:} User submits mapreduce program and configuration (e.g. no. of workers) to Master node
  \item \textbf{Schedule:} Master schedules resource for map and reduce tasks (master does not handle actual data)
  \item \textbf{Read:} Input files are separated into splits of 128MB. Each split corresponds to one map task. Each worker executes map tasks 1 ata a time 
  \item \textbf{Map phase:} Each worker iterates over each key,value tuple and applies the map function 
  \item \textbf{Local write: } each worker writes the output of map to intermiediate files on its local disk.These filees are partitioned by key 
  \item \textbf{Remote read:} each reduce worker is responsible for $\geq$ key. For each key, it reads the data it needs from the corresponding partitioon of each mapper's local disk
  \item \textbf{Write: } output of the reduce function is written (usually to a distributed file system such as HDFS)
\end{enumerate}
  

\textbf{Interface}
\begin{itemize}
  \item map(k,v) $\rightarrow$ list(k',v')
  \item reduce 
\end{itemize}



% TODO: L2  

\subsection*{L3: No SQL Overview}

\textbf{NoSQL}
\begin{itemize}
  \item Not Only SQL: can include sql
  \item Stores data in a format other than relational DB 
  \item Sql refers to to relational DBMS, not the querying language - NoSQL can have querying lang too 
  \item Used for large volumes of data and data that does not fit in a structured data (e.g. some has image, some don't)
\end{itemize}

\textbf{Propertiess}
\begin{itemize}
  \item Horizontal Scalable: easy to partition and distribute across machines 
  \item Replicate and distributed over many servers 
  \item Simple call interface 
  \item Often weaker concurrency model than RDBMS 
  \item Efficient use of distributed indexes and RAM 
  \item Flexible schema
\end{itemize}


\textbf{Major NoSQL DB}
\begin{itemize}
  \item Key-stores
  \begin{itemize}
    \item Stores mapping (associations) bewteen keys and values 
    \item Keys are usually primitives (int,str,raw bytes etc) that can be easily queried 
    \item Values can be primitive or complex; usually cannot be easily queried (lists, JSON, HTML, BLOB)
    \item \textbf{Operations}
    \begin{itemize}
      \item Get - fetch value with key 
      \item Put - set value with key 
      \item Multi-Get, multi-put, range queries (must be comparable, e.g. int, str)
    \end{itemize}
    \item \textbf{Suitable for}
    \begin{itemize}
      \item Smal continuous read and writes
      \item Storing basic information or no clear schema
      \item Complex queries are rarely required
    \end{itemize}
    \item E.g. Storing user sesions, caches, user data that is often processed individually
    \item \textbf{Implementation}
    \begin{itemize}
      \item Non-persistent: Just a big in memory hash table (E.g. redis, memcached) that needs to be regularly backed up to disk
      \item Persistent: data is stored persistently to disk (E.g. RocksDB, Dynamo, Riak)
    \end{itemize}
  \end{itemize}

  \item Wide-column databases - stored sparsely
  \includegraphics*[width=6cm]{wide_col} 
  \begin{itemize}
    \item Rows describe entities
    \item Related groups of columns are grouped as column families (similar to separate tables, except they share the same row)
    \item Sparsity: If a cloumn is not used for a row, it doesn't use space (saves space for sparse data)
  \end{itemize}
  \item Document stores 
  \includegraphics*[width=6cm]{doc_model}
  \begin{itemize}
    \item no schema (flexible schema)
    \item A data base can have multiple collections 
    \item A collection (tables) can have multiple documents (rows)
    \item A document is a JSON-like object with field (columns) and values 
    \item Different documents can have different field and can be nested   
    \item \textbf{Querying}
    \begin{itemize}
      \item Unlike key val stores, doc stores allow querying based on the content 
      \item If the field does not exist on the doc, we just skip it when doing CRUD
    \end{itemize}
  \end{itemize}
  \item Graph databases
  \begin{itemize}
    \item Need to store information about the nodes and edges
  \end{itemize}
  \item Vector Databases
  \begin{itemize}
    \item Store vectors (each row is a point in d dimensions)
    \item Usually dense, numerical, and high-dimensional 
    \item Allow fast similarity search via locality sensitive hashing (LSH), similar to min-hashing
    \item Scalable, real-time updates, replication
    \item Good for LLM and vision models as they need to be converted to vectors, and search, recommendation, clustering can be easily added 
    \item E.g. Milvus, Radis, MongoDB, Atlas, Weaviate
  \end{itemize}
\end{itemize}

\textbf{Consistency}
\includegraphics*[width=7cm]{consistency}
\begin{itemize}
  \item Strong: Any reads on all observers immediately read the same result after update (uses locks, higher latency)
  \item Eventual: If the system is working and we wait long enough, eventually all reads will produce the same value (correctness affected)
\end{itemize}

\textbf{BASE}
\begin{itemize}
  \item \textbf{B}asically \textbf{A}vailable - basic writing and reading operations are available most of the time 
  \item \textbf{S}oft state: without guarantees, we only have some probability of knowing the state at any time 
  \item \textbf{E}ventually consistent
  \item Eventual consistency offers better availability at the cost of weaker consistency 
  \item NoSQL allows for weaker consistency guarantees, and can be tuned to be stronger (tunable consistency)
  \item Suitable for statistical queries and social media feed but not suited for financial transactions 
\end{itemize}

\textbf{Duplication}
\begin{itemize}
  \item Motivation: Support join statments $\rightarrow$ how do we join 2 tables to form 1 new table 
  \item Some optimizations in SQL may not be possible in NoSQL
  \item \textbf{Denoormalization: } 
  \begin{itemize}
    \item Storage is cheap! Duplicate data to boost efficiency
    \item Tables are designed around potential join queries (pre-create the join tables)
    \item Good if the queries types are fixed 
    \item What if a field is updated? $\rightarrow$ changes need to be propagated to multiple table 
  \end{itemize}
\end{itemize}

\includegraphics*[width=7cm]{nosql_pros_cons}
\begin{itemize}
  \item Depends on: 
  \begin{enumerate}
    \item if denormalization is suitable
    \item importance of consistency 
    \item complexity of queries (joins Vs read/write)
  \end{enumerate}
\end{itemize}

% Tutorials


% Misc

\end{multicols}
\end{document}